"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7481],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},59814:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"schemas/custom-validation/index","title":"Custom Validation","description":"All schema types support adding custom validation during the parsing step (see the Parser action for more details).","source":"@site/docs/4-schemas/3-custom-validation/index.md","sourceDirName":"4-schemas/3-custom-validation","slug":"/schemas/custom-validation/","permalink":"/docs/schemas/custom-validation/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Custom Validation"},"sidebar":"tutorialSidebar","previous":{"title":"Defaults & Links","permalink":"/docs/schemas/defaults-and-links/"},"next":{"title":"Type Inference","permalink":"/docs/schemas/type-inference/"}}');var a=t(74848),i=t(28453);const r={title:"Custom Validation"},o="Custom Validation",l={},d=[{value:"Validators",id:"validators",level:2},{value:"Recursive Schemas",id:"recursive-schemas",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"custom-validation",children:"Custom Validation"})}),"\n",(0,a.jsxs)(n.p,{children:["All schema types support adding custom validation during the ",(0,a.jsx)(n.strong,{children:"parsing step"})," (see the ",(0,a.jsx)(n.a,{href:"/docs/schemas/actions/parse",children:(0,a.jsx)(n.code,{children:"Parser"})})," action for more details)."]}),"\n",(0,a.jsx)(n.p,{children:"There are three kinds of validators:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"putValidate"}),": Applied on put actions (e.g. ",(0,a.jsx)(n.a,{href:"/docs/entities/actions/put-item/",children:(0,a.jsx)(n.code,{children:"PutItemCommand"})}),")"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"updateValidate"}),": Applied on update actions (e.g. ",(0,a.jsx)(n.a,{href:"/docs/entities/actions/update-item/",children:(0,a.jsx)(n.code,{children:"UpdateItemCommand"})}),")"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"keyValidate"}),": Overrides other validators on key schemas (ignored otherwise)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"validate"})," method is a shorthand that acts as ",(0,a.jsx)(n.code,{children:"keyValidate"})," on key schemas and ",(0,a.jsx)(n.code,{children:"putValidate"})," otherwise."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["\u261d\ufe0f In order for the ",(0,a.jsx)(n.code,{children:".validate(...)"})," shorthand to work properly on key schemas, make sure to use it ",(0,a.jsx)(n.strong,{children:"after"})," calling ",(0,a.jsx)(n.code,{children:".key()"}),"."]})}),"\n",(0,a.jsx)(n.h2,{id:"validators",children:"Validators"}),"\n",(0,a.jsxs)(n.p,{children:["A custom ",(0,a.jsx)(n.strong,{children:"validator"})," is a function that takes an input (validated by the schema) and returns a ",(0,a.jsx)(n.code,{children:"boolean"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["For instance, you can make sure that a ",(0,a.jsx)(n.code,{children:"string"})," has more than 3 characters like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const nameSchema = string().validate(\n  // \ud83d\ude4c Types are correctly inferred!\n  name => name.length > 3\n)\n\n// \u274c Raises a `parsing.customValidationFailed` error\nnameSchema.build(Parser).parse('foo')\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In case of invalid value, you can ",(0,a.jsxs)(n.strong,{children:["return a ",(0,a.jsx)(n.code,{children:"string"})]})," to provide more context through the error message:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const nameSchema = string().validate(name =>\n  name.length > 3 ? true : 'Provide a longer name'\n)\n\nnameSchema.build(Parser).parse('foo')\n// => \u274c Custom validation for attribute 'name' failed with message: Provide a longer name.\n"})}),"\n",(0,a.jsx)(n.p,{children:"Finally, note that the schema itself is also passed to the validator:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import type { Schema } from 'dynamodb-toolbox/schema'\n\nconst validator = (input: unknown, attr: Schema) => {\n  ... // custom validation here\n}\n\nconst mySchema = item({\n  name: string().validate(validator)\n})\n"})}),"\n",(0,a.jsx)(n.h2,{id:"recursive-schemas",children:"Recursive Schemas"}),"\n",(0,a.jsxs)(n.p,{children:["Validators are a great way to create ",(0,a.jsx)(n.strong,{children:"recursive schemas"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { Parser } from 'dynamodb-toolbox/schema/actions/parse'\n\nconst isValidBulletList = (bulletList: unknown): boolean =>\n  bulletListSchema.build(Parser).validate(bulletList)\n\nconst bulletListSchema = item({\n  title: string(),\n  subBulletList: any()\n    .optional()\n    .validate(isValidBulletList)\n})\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:["Actually, you can improve the performances of this code by instanciating a single ",(0,a.jsx)(n.code,{children:"Parser"}),":"]}),(0,a.jsxs)(t,{className:"details-in-admonition",children:[(0,a.jsxs)("summary",{children:["\ud83d\udd0e ",(0,a.jsx)("b",{children:"Show code"})]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"let bulletListParser:\n  | Parser<typeof bulletListSchema>\n  | undefined\n\nconst isValidBulletList = (\n  bulletList: unknown\n): boolean => {\n  if (bulletListParser === undefined) {\n    bulletListParser = bulletListSchema.build(Parser)\n  }\n\n  return bulletListParser.validate(bulletList)\n}\n\nconst bulletListSchema = item({\n  title: string(),\n  subBulletList: any()\n    .optional()\n    .validate(isValidBulletList)\n})\n"})})]})]}),"\n",(0,a.jsxs)(n.p,{children:["In those cases, type inference ",(0,a.jsx)(n.strong,{children:"only works partially"})," as the ",(0,a.jsx)(n.code,{children:"subBulletList"})," property is inferred as ",(0,a.jsx)(n.code,{children:"unknown"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["However, a ",(0,a.jsx)(n.strong,{children:"slight override"})," of the inferred types gets you there:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import type { FormattedValue } from 'dynamodb-toolbox/schema/actions/format'\n\n// \ud83d\ude4c Works as intended!\ntype FormattedBulletList = FormattedValue<\n  typeof bulletListSchema\n> & { subBulletList?: FormattedBulletList }\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);